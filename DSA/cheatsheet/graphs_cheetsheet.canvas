{
	"nodes":[
		{"id":"d938802bdb6174e7","x":240,"y":-429,"width":480,"height":1129,"type":"group","label":"Shortest Path Algorithms"},
		{"id":"4894221b202961a4","type":"group","x":-340,"y":-786,"width":400,"height":1096,"label":"Pillars of graph"},
		{"id":"ead55dae971afd51","x":-1683,"y":1740,"width":995,"height":388,"color":"2","type":"group","label":"MST of graph"},
		{"id":"f19eb4894bcd5546","type":"text","text":"```cpp\nclass Solution {\n   public:\n    vector<bool> visited;\n    stack<int> st;\n    void DFS(int u, vector<int> adj[]) {\n        visited[u] = true;\n        for (int &v : adj[u]) {\n            if (!visited[v]) {\n                DFS(v, adj);\n            }\n        }\n        st.push(u);\n    }\n    vector<int> topoSort(int V, vector<int> adj[]) {\n        visited.resize(V, false);\n        vector<int> result;\n        for (int i = 0; i < V; i++) {\n            if (!visited[i]) {\n                DFS(i, adj);\n            }\n        }\n        while (!st.empty()) {\n            result.push_back(st.top());\n            st.pop();\n        }\n        return result;\n    }\n};\n\n```","x":-1615,"y":-1441,"width":700,"height":675},
		{"id":"b0fe566f48397124","type":"text","text":"```cpp\n\nclass Solution {\n   public:\n    vector<int> topoSort(int V, vector<int> adj[]) {\n        vector<int> result;\n        unordered_map<int, int> indegree;\n        queue<int> que;\n\n        for (int i = 0; i < V; i++) {\n            for (int &child : adj[i]) {\n                indegree[child]++;\n            }\n        }\n\n        for (int i = 0; i < V; i++) {\n            if (indegree[i] == 0) {\n                que.push(i);\n            }\n        }\n\n        while (!que.empty()) {\n            int curr = que.front();\n            result.push_back(curr);\n            que.pop();\n\n            for (int &v : adj[curr]) {\n                indegree[v]--;\n                if (indegree[v] == 0) {\n                    que.push(v);\n                }\n            }\n        }\n        return result;\n    }\n};\n```","x":-1615,"y":-633,"width":700,"height":800},
		{"id":"b6acb57f84c3f9cf","type":"text","text":"# topological Sorting \n\nsimple dfs algorithm with stack based approach","x":-320,"y":-766,"width":360,"height":267,"color":"4"},
		{"id":"3c833ae1466bbed7","type":"text","text":"Kahn's algorithm \n\nIts nothing but topological sorting using BFS","x":-320,"y":-366,"width":360,"height":267,"color":"4"},
		{"id":"14f344500e8a6986","type":"text","text":"DSU\n\nRank and Size are two approaches.\n\nGenerally used in questions of sparse graph","x":-320,"y":45,"width":360,"height":245,"color":"4"},
		{"id":"852a08b3d017b750","type":"text","text":"```cpp\nclass Solution {\n   public:\n    vector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {\n        vector<int> result(V, 1e8);\n        result[S] = 0;\n\n        for (int i = 1; i <= V - 1; i++) {\n            for (auto& edge : edges) {\n                int u = edge[0];\n                int v = edge[1];\n                int wt = edge[2];\n\n                if (result[u] != 1e8 && result[u] + wt < result[v]) {\n                    result[v] = result[u] + wt;\n                }\n            }\n        }\n\n        // now detect -ve cycle\n        // relax 1 more time -> if it relaxes we are in -ve cycle\n        for (auto& edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            int wt = edge[2];\n\n            if (result[u] != 1e8 && result[u] + wt < result[v]) {\n                return {-1};\n            }\n        }\n\n        return result;\n    }\n};\n```","x":1256,"y":-1103,"width":864,"height":780},
		{"id":"3bf9cc81d3be98ad","type":"text","text":"```cpp\nclass Solution {\n   public:\n    void shortest_distance(vector<vector<int>>& grid) {\n        int n = grid.size();\n\n        // mark -ve weight which represent unconnected as INT_MAX\n        // since input is maximum 1000 ... we are taking 10000 as safer side\n        // you can infact have INT_MAX as well\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == -1) {\n                    grid[i][j] = 10000;\n                }\n            }\n        }\n\n        // Floyd Warshall visit source from via node\n        for (int via = 0; via < n; via++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = min(grid[i][j], grid[i][via] + grid[via][j]);\n                }\n            }\n        }\n\n        // This step restores back values, since we are not returning anything\n        // we are supposed to modify matrix in-place but since previously\n        // we modified -1 to INT_MAX (or 10000) we need to reverse that\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 10000) {\n                    grid[i][j] = -1;\n                }\n            }\n        }\n    }\n};\n```","x":1256,"y":-232,"width":864,"height":865},
		{"id":"17f875e537d84b57","x":1256,"y":680,"width":864,"height":680,"type":"text","text":"```cpp\n\nclass Solution {\n   public:\n    vector<int> dijkstra(int V, vector<vector<int>> adj[], int S) {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        vector<int> result(V, INT_MAX);\n\n        result[S] = 0;\n        pq.push({0, S});  // souce se source tak pohoch ne me 0 lag rha h\n\n        while (!pq.empty()) {\n            int cost = pq.top().first;\n            int node = pq.top().second;\n            pq.pop();\n\n            for (auto &x : adj[node]) {\n                int subnode = x[0];\n                int curr_cost = x[1];\n\n                if (cost + curr_cost < result[subnode]) {\n                    result[subnode] = cost + curr_cost;\n                    pq.push({cost + curr_cost, subnode});\n                }\n            }\n        }\n\n        return result;\n    }\n};\n\n```"},
		{"id":"4f6907fb5b3631e0","type":"text","text":"## bellman-ford\nshortest path from single source to all vertices in a graph\n\n\n> single source to all vertices shortest path\n\n```\ni=1; i<=V-1 times\n```\n\n> Note: for cycle detection.. relax 1 more time ... if weight changes... then it has -ve cycle","x":280,"y":-409,"width":400,"height":355},
		{"id":"f65393254db44a8b","type":"text","text":"# Floydd-warshall\n\nShortest path betwen any source to any destination\n","x":280,"y":68,"width":400,"height":265},
		{"id":"282f2ba7f4334898","type":"text","text":"# Dijkstra's \n\nShortest path betwen any source to any destination\n","x":280,"y":413,"width":400,"height":220},
		{"id":"d198e5ac4a74f853","type":"text","text":"```cpp\nclass DSU {\n   public:\n    void unionSet(vector<int> &parent, vector<int> &rank, int x, int y) {\n        int x_parent = find(parent, x);\n        int y_parent = find(parent, y);\n\n        if (x_parent == y_parent) {\n            return;\n        }\n\n        if (rank[x_parent] > rank[y_parent]) {\n            // jiska rank jyada hoga vo daddy banega\n            parent[y_parent] = x_parent;\n        } else if (rank[x_parent] < rank[y_parent]) {\n            // jiska rank jyada hoga vo daddy banega\n            parent[x_parent] = y_parent;\n        } else {\n            // rank same hua toh kisi ek ko dusre ka daddy bana do\n            // jisko bhi daddy banaya uska rank increment kardo\n            parent[y_parent] = x_parent;  // y became daddy of x\n            rank[x_parent]++;\n        }\n    }\n    int find(vector<int> &parent, int x) {\n        if (parent[x] == x)\n            return x;\n\n        return parent[x] = find(parent, parent[x]);\n    }\n};\n```","x":-2240,"y":541,"width":700,"height":819},
		{"id":"c70b4017e37d6997","x":-1480,"y":541,"width":635,"height":819,"type":"text","text":"```cpp\nclass DSU {\n   public:\n    vector<int> parent;\n    vector<int> size;\n    DSU(int n) {\n        parent.resize(n);\n        size.resize(n);\n\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n    void unionSet(int x, int y) {\n        int x_parent = find(x);\n        int y_parent = find(y);\n\n        if (x_parent == y_parent) {\n            return;\n        }\n\n        if (size[x_parent] >= size[y_parent]) {\n            parent[y_parent] = x_parent;\n            size[x_parent] += size[y_parent];\n        } else {\n            parent[x_parent] = y_parent;\n            size[y_parent] += size[x_parent];\n        }\n    }\n    int find(int x) {\n        if (parent[x] == x)\n            return x;\n\n        return parent[x] = find(parent[x]);\n    }\n};\n```"},
		{"id":"c25cbb0e8c328ffc","x":60,"y":860,"width":877,"height":1700,"type":"text","text":"```cpp\nclass Solution {\n   public:\n    vector<bool> visited;\n    stack<int> st;\n    void topoSortDFS(int u, vector<vector<int>>& adj) {\n        // if already visited return\n        if (visited[u]) {\n            return;\n        }\n\n        // mark visited\n        visited[u] = true;\n\n        for (int& v : adj[u]) {\n            if (!visited[v]) {\n                topoSortDFS(v, adj);\n            }\n        }\n\n        st.push(u);\n    }\n\n    void topoSort(int V, vector<vector<int>>& adj) {\n        for (int i = 0; i < adj.size(); i++) {\n            if (!visited[i]) {\n                topoSortDFS(i, adj);\n            }\n        }\n    }\n\n    void DFSkosaraju(int node, vector<vector<int>>& adjReversed) {\n        if (visited[node]) {\n            return;\n        }\n\n        // mark visited\n        visited[node] = true;\n\n        for (auto& x : adjReversed[node]) {\n            if (!visited[x]) {\n                DFSkosaraju(x, adjReversed);\n            }\n        }\n    }\n\n    int kosaraju(int V, vector<vector<int>>& adj) {\n        // make a reverse graph\n        vector<vector<int>> adjReversed(V);\n        visited.resize(V, false);\n\n        // fill reverse of grpah (switch u->v with v->u)\n        for (int u = 0; u < V; u++) {\n            for (auto& v : adj[u]) {\n                adjReversed[v].push_back(u);\n            }\n        }\n\n        // get topological sorted order in stack;\n        topoSort(V, adj);\n\n        // run dfs on graph once more to get SCC count\n        int countSCC = 0;\n        visited = vector<bool>(V, false);\n        while (!st.empty()) {\n            int node = st.top();\n            st.pop();\n\n            if (!visited[node]) {\n                DFSkosaraju(node, adjReversed);\n                countSCC++;\n            }\n        }\n\n        return countSCC;\n    }\n};\n```"},
		{"id":"964193af38d1f5eb","type":"text","text":"Prims Algorithm\n\nUsed to find MST of a graph\nHeap based approach\nValue in heap {wt, node}","x":-1620,"y":1818,"width":366,"height":232,"color":"5"},
		{"id":"49012536f0eda391","type":"text","text":"Kruskal Algorithm\n\nUsed to find MST of a graph... it uses DSU","x":-1162,"y":1818,"width":402,"height":232,"color":"6"},
		{"id":"74080e84d3e1e03d","x":-2026,"y":2415,"width":866,"height":865,"color":"5","type":"text","text":"```cpp\nclass Solution {\n   public:\n    int spanningTree(int V, vector<vector<int>> adj[]) {\n        // weight (heap on basis of this)\n        priority_queue<P, vector<P>, greater<P>> pq;  // {wt, node}\n        vector<bool> visited(V, false);\n        pq.push({0, 0});\n\n        int sum = 0;\n\n        while (!pq.empty()) {\n            int wt = pq.top().first;\n            int node = pq.top().second;\n            pq.pop();\n\n            // check if node is visited\n            if (visited[node]) {\n                continue;\n            }\n\n            visited[node] = true;\n            sum += wt;\n\n            for (auto &x : adj[node]) {\n                int neighbour = x[0];\n                int neighbour_wt = x[1];\n\n                if (!visited[neighbour]) {\n                    pq.push({neighbour_wt, neighbour});\n                }\n            }\n        }\n\n        return sum;\n    }\n};\n```"},
		{"id":"9e5aa06d2b7da811","x":-1000,"y":2415,"width":761,"height":1140,"color":"6","type":"text","text":"```cpp\n\nclass Solution {\n   public:\n    vector<int> parent;\n    vector<int> rank;\n    int find(int x) {\n        if (parent[x] == x) {\n            return x;\n        }\n        return parent[x] = find(parent[x]);\n    }\n\n    void unionSet(int x, int y) {\n        int nodeX = find(x);\n        int nodeY = find(y);\n\n        // both belong to different component no need to merge\n        if (nodeX == nodeY) {\n            return;\n        }\n\n        // check rank\n        if (rank[nodeX] > rank[nodeY]) {\n            parent[nodeY] = nodeX;  // x rank is more so its papa\n        } else if (rank[nodeX] < rank[nodeY]) {\n            parent[nodeX] = nodeY;\n        } else {\n            // both rank are same (make any one as parent)\n            parent[nodeY] = nodeX;\n            rank[nodeX]++;\n        }\n    }\n\n    int kruskal(vector<vector<int>> &vec) {\n        int sum = 0;\n\n        for (auto &temp : vec) {\n            int u = temp[0];\n            int v = temp[1];\n            int wt = temp[2];\n\n            int uParent = find(u);\n            int vParent = find(v);\n\n            if (uParent != vParent) {\n                unionSet(u, v);\n                sum += wt;\n            }\n        }\n\n        return sum;\n    }\n\n    int spanningTree(int V, vector<vector<int>> adj[]) {\n        parent.resize(V);\n        rank.resize(V, 0);\n        vector<vector<int>> vec;\n\n        // DSU: initally all vertices are seperated and each of them is itself parent\n        for (int i = 0; i < V; i++) {\n            parent[i] = i;\n        }\n\n        for (int i = 0; i < V; i++) {\n            for (auto &temp : adj[i]) {\n                int u = i;\n                int v = temp[0];\n                int d = temp[1];\n\n                vec.push_back({u, v, d});\n            }\n        }\n\n        sort(vec.begin(), vec.end(), [&](auto &x, auto &y) {  // ELOG(E)\n            return x[2] < y[2];\n        });\n\n        return kruskal(vec);\n    }\n};\n```"},
		{"id":"6a561e9d2f43c669","type":"text","text":"Kosaraju \n\nUsed to find SCC in a graph","x":-360,"y":1471,"width":250,"height":178}
	],
	"edges":[
		{"id":"b86d5d2d9f50ff49","fromNode":"4f6907fb5b3631e0","fromSide":"right","toNode":"852a08b3d017b750","toSide":"left"},
		{"id":"5530f579946046b2","fromNode":"b6acb57f84c3f9cf","fromSide":"left","toNode":"f19eb4894bcd5546","toSide":"right"},
		{"id":"af2af642c2ee3470","fromNode":"3c833ae1466bbed7","fromSide":"left","toNode":"b0fe566f48397124","toSide":"right"},
		{"id":"89c622834b93401b","fromNode":"14f344500e8a6986","fromSide":"left","toNode":"d198e5ac4a74f853","toSide":"top","label":"by rank"},
		{"id":"6de51a812a00a8ed","fromNode":"f65393254db44a8b","fromSide":"right","toNode":"3bf9cc81d3be98ad","toSide":"left"},
		{"id":"68c6690d5d3e720e","fromNode":"282f2ba7f4334898","fromSide":"right","toNode":"17f875e537d84b57","toSide":"left"},
		{"id":"a4b64083dc2e5b88","fromNode":"14f344500e8a6986","fromSide":"bottom","toNode":"c70b4017e37d6997","toSide":"top","label":"by size"},
		{"id":"955ec6fd7289cf7b","fromNode":"6a561e9d2f43c669","fromSide":"right","toNode":"c25cbb0e8c328ffc","toSide":"left"},
		{"id":"7d9edd0b8b1c21b8","fromNode":"964193af38d1f5eb","fromSide":"right","toNode":"49012536f0eda391","toSide":"left","toEnd":"none"},
		{"id":"c5c74c5e50ad30b9","fromNode":"49012536f0eda391","fromSide":"bottom","toNode":"9e5aa06d2b7da811","toSide":"top"},
		{"id":"ff8981d7420fff5c","fromNode":"964193af38d1f5eb","fromSide":"bottom","toNode":"74080e84d3e1e03d","toSide":"top"}
	]
}